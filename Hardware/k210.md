#### 名词解释

##### PLL

锁相环(Phase Locked Loop)，使电路上的时钟和某一外部时钟的相位同步。PLL的主要用途是作为频率合成器，产生更宽范围的频率输出。也可以用作抖动滤波器，或补充时钟网络的延迟。

##### APB

一个总线协议，几乎成为一种标准的片上总线结构。主要用于低带宽的外设连接。

#### 系统控制器

##### 系统控制器的寄存器

系统控制器是个外设，它负责所有与系统相关的外设的设置。它的32个32位寄存器都映射在内存里。

| 编号  | 名称          | 描述                                                         |
| ----- | ------------- | ------------------------------------------------------------ |
| 0     | git_id        | Git短提交id。只读寄存器，git的commit id共160位，而它只能提供前32位，所以叫"short commit id"。 |
| 1     | clk_freq      | 系统时钟频率。只读寄存器。                                   |
| 2     | pll0          | PLL0控制器。可写，其中clkr0,clkf0,clkod0用于计算输出频率，其中clkr0,clkf0,clkod0,bwadj0用于控制输入频率，其中pll_bypass0设置是否bypass pll0(1:bypass, 0:do not bypass)，pll_out_en0位控制pll0的时钟使能，pll_pwrd0控制pll0的启动(0:power off, 1:power on)，pll_reset0用于重置pll0(0:不重置，1:重置) |
| 3     | pll1          | PLL1控制器。可写，其中clkr1,clkf1,clkod1用于计算输出频率，其中clkr1,clkf1,clkod1,bwadj1用于控制输入频率，其中其中pll_bypass1设置是否bypass pll1(1:bypass, 0:do not bypass)，pll_out_en1位控制pll1的时钟使能，pll_pwrd1控制pll1的启动(0:power off, 1:power on)，pll_reset1用于重置pll1(0:不重置，1:重置) |
| 4     | pll2          | PLL2控制器。可写，其中clkr2,clkf2,clkod2用于计算输出频率，其中clkr2,clkf2,clkod2,bwadj2用于控制输入频率，其中其中pll_bypass2设置是否bypass pll2(1:bypass, 0:do not bypass)，pll_out_en2位控制pll2的时钟使能，其中pll_ckin_sel2将pll2设为时钟源，pll_pwrd2控制pll2的启动(0:power off, 1:power on)，pll_reset2用于重置pll2(0:不重置，1:重置) |
| 5     | resv5         | 保留                                                         |
| 6     | pll_lock      | PLL锁测试器。其中pll_lock0~2均只读，pll_lock0=3则pll0已锁，pll_lock1=1则pll1已锁，pll_lock2=1则pll2已锁。其中pll_lip_clear0~2用于清空对应pll的slip，置1则清空对应pll的slip。 |
| 7     | rom_error     | AXI ROM测试器                                                |
| 8     | clk_sel0      | 时钟选择控制器0。可写，其中aclk_sel设置aclk为时钟源；其中aclk_divider_sel占用2位，控制aclk的阈值；其中apb0~2_clk_sel分别占用3位，分别控制apb0~2的阈值；其中spi3_clk_sel设置spi3为时钟源；其中timer0~2_clk_sel分别设置timer0~2为时钟源；其它为保留位。 |
| 9     | clk_sel1      | 时钟选择控制器1。可写，仅第一位有效，spi3_sample_clk_sel将spi3_sample设为时钟源。 |
| 10    | clk_en_cent   | 中心时钟使能。可写，每一位控制一个时钟使能，共用6个位控制cpu, sram0~1, apb0~2，其余位保留。其中apb0~2分别控制着若干外设。置1使能，置0不使能。 |
| 11    | clk_en_peri   | 外部时钟使能。可写，每一位控制一个外设的时钟全能。置1使能，置0不使能。 |
| 12    | soft_reset    | 软重置。可写，仅第一位有效。置1重置，置0不重置。             |
| 13    | peri-reset    | 外重置。可写，每一位控制一个外设。置1重置，置0不重置。       |
| 14    | clk_th0       | 时钟阈值控制器0。可写，控制阈值宽度为4的外设的阈值，控制的外设有5个：sram0~1, ai, dvp, rom |
| 15    | clk_th1       | 时钟阈值控制器1。可写，控制阈值宽度为8的外设的阈值，控制的外设有4个：spi0~3 |
| 16    | clk_th2       | 时钟阈值控制器2。可写，控制阈值宽度为8的外设的阈值，控制的外设有3个：timer0~2，剩余8位为保留位 |
| 17    | clk_th3       | 时钟阈值控制器3。可写，控制阈值宽度为16的外设的阈值，控制的外设有2个：i2s0~1_clk_threshold |
| 18    | clk_th4       | 时钟阈值控制器4。可写，控制2个阈值宽度为8的外设的阈值：i2s0~1_mclk_threshold，还控制1个阈值宽度为16的外设的阈值：i2s2_clk_threshold |
| 19    | clk_th5       | 时钟阈值控制器5。可写，控制阈值宽度为8的外设的阈值，控制的外设有4个：i2s2_mclk_threshold, i2c0~2_clk_threshold |
| 20    | clk_th6       | 时钟阈值控制器6。可写，控制阈值宽度为8的外设的阈值，控制的外设有2个：wdt0~1_clk_threshold, 剩余16位为保留位 |
| 21    | misc          | 杂项控制器。有1个1位的sip_dvp_data_enable，1为使能，0为不使能 |
| 22    | peri          | 外设控制器                                                   |
| 23    | spi_sleep     | SPI睡眠控制器                                                |
| 24    | reset_status  | reset源的状态。wdt0~1_reset_sts和soft_reset_sts代表其各自的reset状态，1为reset，0为非reset，reset_sts_clr如写入1则清空reset状态。其余为保留位。 |
| 25    | dma_sel0      | DMA握手控制器0。可写，控制dma_sel0~4共5个6位宽的channel，其余2位保留 |
| 26    | dma_sel1      | DMA握手控制器1。可写，控制dma_sel5这个6位宽的channel，其余26位保留 |
| 27    | power_sel     | IO电源模式选择控制器。可写，power_mode_sel0~7共8个1位的项控制8种电源模式，1为使能0为不使能，其余24位保留 |
| 28-31 | resv28-resv31 | 保留                                                         |

##### 系统控制器的功能

- 外设时钟的使能或取消使能

  共有三条总线(apb0, apb1, apb2)，所有外设都分配在这三条总线上。在**clk_en_cent**寄存器上有3位分别控制这三条总线时钟的使能或取消使能。

  共有三种类型的外设。一种外设是PLL，它们的时钟使能由各自的寄存器控制(**pll0**, **pll1**, **pll2**)；一种连在内部总线上，它们是CPU、内存和外部总线，它们的时钟使能由寄存器**clk_en_cent**控制；其它外设连在外部总线上，它们的时钟使能由**clk_en_peri**控制。

  对于PLL或连在内部总线上的设备，只要该外设对应的时钟使能位置1，即可使能该设备；对于连接在外部总线apb上的设备，则需要先使能该外设所在的apb总线的时钟，再使能该外设的时钟。

  设备要取消使能，只要将该设备的使能位置0即可。

- 时钟阈值的设置与获取

  不同的外设其阈值位宽是不一样的，共有2、3、4、8、16五种情况。其中aclk_divider(2位)、apb0~2(各3位)由寄存器**clk_sel0**控制。其中sram0~1、ai、dvp、rom的阈值均为4位，由寄存器**clk_th0**控制。其中spi0~3的阈值为8位，由寄存器**clk_th1**控制。其中timer0~2的阈值为8位，由寄存器**clk_th2**控制。其中i2s0~1的阈值为16位，由寄存器**clk_th3**控制。其中i2s2的阈值为16位，i2s0~1_mclk的阈值为8位，由寄存器**clk_th4**控制。其中i2s2_mclk，i2c0~2的阈值为8位，由寄存器**clk_th5**控制。其中wdt0~1的阈值为8位，由寄存器**clk_th6**控制。

  设置外设的时钟阈值就是向相应的位写入数据，获取外设的时钟阈值就是从相应的位读取数据。

- 时钟选择的设置与获取

  可以从寄存器**pll0~2**相应的pll_bypass位置1来设置绕过相应的PLL。可以从寄存器**pll2**的pll_ckin_sel2置0x3(2位)来使能该时钟。可以从寄存器**clk_sel0**相应的位来使能相应的外设时钟，可设置的外设有aclk, spi3, timer0~2。可以从寄存器**clk_sel1**的spi3_sample_clk_sel位来使能该时钟，该寄存器仅此一个有效位。

  时钟选择的获取就是从如上寄存器中的相应位获取对应的值。

- 获取PLL的频率

  ```
  FOUT = FIN / NR * NF /OD	# 输出频率 = 输入频率 / R分频器 * N计数器 / od
  	# nr = pll.clkr + 1
  	# nf = pll.clkf + 1
  	# od = pll.clkod + 1
  	# FIN : 如PLL0~1则为26000000UL；如PLL2则从pll2.pll_ckin_sel2获取对应select(可能是SOURCE_IN0, SOURCE_PLL0, SOURCE_PLL1)，如SOURCE_IN0则为26000000UL,如SOURCE_PLL0~1则按上述公式再算一遍。
  ```

  

- 获取各种设备的基本时钟频率

  | clock                            | divider | 频率          |
  | -------------------------------- | ------- | ------------- |
  | IN0                              |         | 26000000UL    |
  | directly under PLL时钟域(PLL0~2) | gated   | 对应PLL的频率 |
  | directly under ACLK时钟域        |         |               |
  |                                  |         |               |
  |                                  |         |               |
  |                                  |         |               |
  |                                  |         |               |
  |                                  |         |               |
  |                                  |         |               |

  

- 设备重置与获取重置状态

  重置的过程就是将寄存器**soft_rest**或**peri_rest**中对应的位置1再置0。

  获取重置状态就是从寄存器**reset_status**中依次读取相应的位，如某一位为1，则表明该位对应的外设被重置了。可以获取重置状态的外设有wdt1, wdt2, soft。最后，应该是通过给reset_sts_clr位置1来清空外设的重置状态。

- PLL的使能与取消使能

  寄存器**pll0~2**分别控制相应PLL的使能与取消全能。

  使能的过程：

  ```
  sysctl->pll.pll_bypass = 0		// 不绕过pll
  sysctl->pll.pll_pwd = 1			// 开启pll
  
  // 重置pll
  sysctl->pll.pll_reset = 0
  sysctl->pll.pll_reset = 1
  asm volatile("nop; nop");
  sysctl->pll.pll_reset = 0
  ```

  取消使能的过程：

  ```
  sysctl->pll.pll_bypass = 1		// 绕过pll
  sysctl->pll.pll_pwrd = 0		// 关闭pll
  ```

- 选择外设DMA通道握手信号

  DMA一共有6个通道，每个通道占6位。前5个通道在寄存器**dma_sel0**，第6个通道在寄存器**dma_sel1**。每个通道可选择的外设有SSI, I2C, UART, AES, SHA, AI, FFT, I2S。

- 设置spi0和dvp数据

  寄存器**misc**的spi_dvp_data_enable位置1则使能，置0则不使能。

- 设置io电源模式

  电源模式共有两种：3.3V和1.8V。寄存器**power_sel**共可选择8种power bank，如电源模式选择1.8V则相应的power bank位置1，如电源模式选择3.3V则相应的power bank位置0。

- CPU频率的获取与设置

- 初始化PLL的频率

- 中断的使能与取消使能

  通过设置**mie**和**mstatus**相应的位实现。

- 获取从启动到现在所用的时间

  从**mcycle**获取CPU周期数，从`sysctl_clock_get_freq()`获取CPU频率，两者相除即为启动到现在所过的时间。

##### 待解决的问题

- 不知道PLL的具体作用。
- 不知道时钟的threshold的具体作用。
- 外设重置可以理解为重置外设的寄存器，那么软重置是什么意思呢？
- 为什么重置状态寄存器只记录wdt0~1和soft的重置呢？其它外设为什么不记录呢？