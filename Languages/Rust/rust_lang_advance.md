#### 11测试

##### 编写测试

测试函数的三种操作：设置数据或状态，运行测试代码，断言结果。

在`fn`前加上`#[test]`，就是给这个函数带上了`test`属性。当执行`cargo test`命令时，Rust会调用标记了`test`属性的函数，并报告测试的结果。

`assert!`宏由标准库提供，它对一个布尔值进行判断，如为真则什么也不做，如为假则调用`panic!`宏。

`assert_eq!`和`assert_ne!`宏用于测试两个值是否相等，如断言失败则打印出这两个值的内容。

可以向`assert!`、`assert_eq!`、`assert_ne!`宏传递可选的信息参数，在它们的必需参数之后的参数都会传递给`format!`宏从而打印出来。

在`fn`前加上`#[should_panic]属性`，则函数panic的时候测试通过，函数没有panic的时候测试失败。这用来测试函数是否生成了panic。还可以给`should_panic`属性增加一个可选的`expected`参数，用以输出一些信息，在测试不通过时显示它从而方便定位问题。

也可以把`Result<T, E>`作为返回值编写测试，此时测试通过则返回`Ok(())`，测试失败则返回带有`String`的`Err`。

##### 控制测试

`cargo test`生成的二进制文件默认是并行运行的，所以测试不能相互依赖、或依赖任何共享的状态。

可以在`#[test]`后面增加`#[ignore]`来忽略某些测试。

详情可参考`man cargo-test`命令。

##### 测试的组织结构

单元测试存在于`src`目录下，与被测代码放在同一文件，位于用`#[cfg(test)]`标准的`tests`模块中。

`#[cfg(test)]`在执行`cargo test`才编译和运行测试代码，在执行`cargo build`时不这么做。因为单元测试的代码和源码在同一文件中，所以才需要`#[cfg(test)]`。

在单元测试里，是允许测试私有函数的。

集成测试存在于`tests`目录，cargo会把`tests`目录下的每一个文件当作一个单独的crate来编译。

集成测试把要测的库看成是外部的，所以需要用`use`来导入它。

`tests`目录对于cargo来说是一个特殊的目录，在执行`cargo test`时会自动编译这个目录下的文件。

`tests`目录中的子目录不会作为单独的crate编译，也不会作为测试结果的一部分出现在测试输出中。这对于集成测试中的子模块来说是有用的。使用子模块和使用其它模块没有区别，都是使用`mod`关键字。

#### 13 函数式编程

##### 闭包

数学上的闭包，个人理解，就是对某种运算封闭的一些对象的**最小**集合。在数据库里也有闭包的概念。Rust里的闭包是一个匿名函数，可以以变量或参数的形式存在，闭包可以捕获调用者作用域中的值。

使用函数获取结果，这个函数一定会在确定的位置被执行。而如果使用闭包，只有当需要这个结果的时候闭包才会执行。

闭包的定义以一对竖线开始，竖线之间是闭包的参数，如有多个参数则以逗号分隔；接下来则是闭包的语句块，如果是多行语句要使用大括号，如果只有一行则可省略大括号。

使用let语句定义一个变量为闭包，意味着这个变量是此闭包的定义，**而不是**此闭包的返回值。

调用闭包和调用函数的形式是一样的。

在定义闭包的时候，不必在参数和返回值上注明类型。因为，和函数不一样，闭包的接口不是暴露在外的，而是只关联于小范围的上下文中，编译器能可靠地推断参数和返回值的类型。注意，闭包的接口类型是**固定的**，如果调用两次闭包而给它传不同类型的参数，则编译器会报错。

为了提高计算效率，可以缓存闭包的返回值，这样在多次调用闭包的时候就可以避免重复计算。Rust的解决方案是：用一个结构体来存放闭包及其调用结果。为了在结构体里定义闭包，需要使用**泛型**和**特性绑定**。

`Fn`是由`std::ops`提供的特性。所有的闭包都要实现特性`Fn`、`FnMut`或`FnOnce`中的一个。

在结构体中使用闭包的形式：需要定义一个泛型，这泛型要用where语法特性绑定`Fn`(或者`FnMut`、`FnOnce`)。在结构体中需要定义一个此泛型的字段用以代表闭包的实例。在结构体中还需要定义一个`Option`类型的字段来保存闭包的结果。

在结构体中使用闭包的逻辑过程：在结构体里的闭包执行前，结构体里`Option`类型的字段值是`None`。第一次请求闭包，`Option`类型的字段值会存储闭包的结果。如果再次请求闭包的结果，则闭包不再执行，而是返回该`Option`字段的值。

在结构体里使用闭包，结构体里的字段应该是私有的，这样可以避免调用者不合理地改变字段的值。应创建`new`方法接收闭包并返回该结构体的实例。应该创建一个方法检查`Option`类型字段的值，如果是`None`则执行闭包并保存它的返回值，如果有值则直接返回该值。

使用值缓存的方法有两个小问题：１，一旦`Option`字段里有了值，则不管给闭包传入什么参数，返回值都不会改变。解决方法是用哈希映射来取代单独一个值。２，闭包传入的值和返回的值类型要一致。解决方法是引入范型。

闭包可以捕获它的调用者里的变量，而函数则不行。因为闭包和它的调用者在相同的作用域里。

闭包捕获其调用者环境的三种方式，对应三个特性：

1. `FnOnce` - 获取所有权。因为同一变量的所有权只能转移一次，所以叫Once。
2. `FnMut` - 获取可变的借用值。
3. `Fn` - 获取不可变的借用值。

`move`关键字可以强制闭包获取其调用者环境中值的所有权。

##### 迭代器