#### 11测试

##### 编写测试

测试函数的三种操作：设置数据或状态，运行测试代码，断言结果。

在`fn`前加上`#[test]`，就是给这个函数带上了`test`属性。当执行`cargo test`命令时，Rust会调用标记了`test`属性的函数，并报告测试的结果。

`assert!`宏由标准库提供，它对一个布尔值进行判断，如为真则什么也不做，如为假则调用`panic!`宏。

`assert_eq!`和`assert_ne!`宏用于测试两个值是否相等，如断言失败则打印出这两个值的内容。

可以向`assert!`、`assert_eq!`、`assert_ne!`宏传递可选的信息参数，在它们的必需参数之后的参数都会传递给`format!`宏从而打印出来。

在`fn`前加上`#[should_panic]属性`，则函数panic的时候测试通过，函数没有panic的时候测试失败。这用来测试函数是否生成了panic。还可以给`should_panic`属性增加一个可选的`expected`参数，用以输出一些信息，在测试不通过时显示它从而方便定位问题。

也可以把`Result<T, E>`作为返回值编写测试，此时测试通过则返回`Ok(())`，测试失败则返回带有`String`的`Err`。

##### 控制测试

`cargo test`生成的二进制文件默认是并行运行的，所以测试不能相互依赖、或依赖任何共享的状态。

可以在`#[test]`后面增加`#[ignore]`来忽略某些测试。

详情可参考`man cargo-test`命令。

##### 测试的组织结构

单元测试存在于`src`目录下，与被测代码放在同一文件，位于用`#[cfg(test)]`标准的`tests`模块中。

`#[cfg(test)]`在执行`cargo test`才编译和运行测试代码，在执行`cargo build`时不这么做。因为单元测试的代码和源码在同一文件中，所以才需要`#[cfg(test)]`。

在单元测试里，是允许测试私有函数的。

集成测试存在于`tests`目录，cargo会把`tests`目录下的每一个文件当作一个单独的crate来编译。

集成测试把要测的库看成是外部的，所以需要用`use`来导入它。

`tests`目录对于cargo来说是一个特殊的目录，在执行`cargo test`时会自动编译这个目录下的文件。

`tests`目录中的子目录不会作为单独的crate编译，也不会作为测试结果的一部分出现在测试输出中。这对于集成测试中的子模块来说是有用的。使用子模块和使用其它模块没有区别，都是使用`mod`关键字。

