#### 变量

变量(使用`let`关键字定义)默认是不可改变的(immutable)。为什么要默认让它不可改变呢？因为不应该改变的变量有可能被其它部分的代码改变其值。

使变量可变的方法是使用`mut`关键字。

不可改变的变量与常量(使用`const`关键字)的区别：常量的值只能来自于常量表达式，变量的值还可来自于函数返回值、或运行时才能计算出的值。

可改变的变量与隐藏(使用`let`关键字)的区别：隐藏的本质是创建了一个新变量，而可改变的变量还是原来那个变量。

#### 数据类型

##### 标量

整型：有符号数以`i`开头，无符号数以`u`开头。长度有8、16、32、64、128四种。特别地`isize`和`usize`这两种整数类型的长度取决于计算机架构，如64架构上它们就是64位的。

浮点型：有两种类型`f32`、`f64`。

布尔型：只有一种类型`bool`。只有两个值`true`和`false`。

字符型：只有一种类型`char`。长度为4字节。

##### 复合类型

元组：多类型值复合，长度固定。使用括号和逗号定义。元组元素的访问方法为通过模式匹配解构、使用点号。

数组：单一类型的复合，长度固定。使用中括号和逗号定义。数据元素的访问方法为通过数组索引访问。

#### 函数

以`fn`关键字定义函数。

参数的类型必须显式地指定。

语句是不返回值的指令，以分号结尾；表达式计算并产生一个值，结尾没有分号。

函数如有返回值，要用箭头`->`声明其类型。`return`用以指明返回值，如没有`return`关键字则最后一个表达式的值为返回值。

#### 控制流

```rust
// if表达式
if 条件 {
    
} else {
    
}

// 使用else if处理多重条件
if 条件 {
    
} else if 条件 {
    
} else {
    
}

// 可在let语句中使用if，以实现C语言中?:运算的效果

// 使用loop实现循环，通过break返回

// 使用while实现循环
while 条件 {
    
}

// 使用for实现循环
for element in a.iter() {
    
}
```

#### 所有权

所有权是rust用以管理内存的方式。

> 栈和堆是数据在内存中的两种组织形式。栈中的数据是大小固定的、有序的，而堆中的数据是大小不定的、散乱的。

所有权规则是说：一个值只能对应一个变量；当变量离开作用域，则值就要被消灭。

rust会在作用域 的末尾，自动调用drop函数，在堆上回收作用域失效的变量的内存。

当多个指针指向堆中的同一个数据时，默认为**移动**，即只有一个指针有效，这样drop函数只要释放有效指针指向的堆中数据即可，避免了二次释放。

如果确实需要复制，而不是移动，则需要使用clone方法。

当数据在栈上时，对数据的操作将会是复制，而不是移动。

一个变量进入函数即被视为离开作用域，当函数退出时函数内的变量被视为离开作用域。

函数返回的值如被另一个变量所有，则不会被drop函数清理掉。

##### 引用与借用

如果只想使用值而不获得它的所有权，则需要`&`符号进行引用。这实际上是用对指针的所有权来代替对值的所有权。

在函数参数里使用引用，就被称为**借用**。

引用默认不可修改。不可变引用可以有多个。

可以在定义和引用的时候都使用`mut`关键字，来使引用可修改。可变引用只能有1个。

悬垂引用是不被允许的，编译器会报错。即引用必须总是有效的。

##### slice

不光可以引用一个整体，还可以引用整体中的一个部分，这就是slice。

字符串slice用`[starting_index..ending_index]`标识。字符串字面值就是一个字符串slice。

数组slice类似于字符串slice，只是它的元素是数字。

#### 结构体

使用`struct`关键字来定义结构体。

结构体与元组都可以包含不同的数据类型，它们的区别是：结构体里的元素有名字，而元组里的元素没有名字；结构体里的元素无序，而元组里元素有序。

要想结构里某个字段可变，整个结构体必须是可变的。

给结构体里的字段赋值，如果变量与字段重名，可以使用简化写法，即只写一个名字。

给结构体里字段赋值，如果某些值与其它的实例相同，可使用`..`从其它实例来创建这个实例。

结构体里的字段也可以没有名字，此时叫元组结构体。

可以使用`impl`关键字给结构体定义方法，这样结构体看上去就像一个对象了。方法的第一个参数总是`self`，代表了调用该方法的结构体自身。

方法也可以有其它参数，定义方式同函数。

当第一个参数不是`self`时，它就不是这个结构体的方法，而是这个结构体的关联函数。

使用方法要用`.`，而使用关联函数要用`::`。

即可以在一个`impl`块里定义多个方法，也可以把不同的方法定义在不同的`impl`块中。

#### 枚举与模式匹配

##### 定义枚举

使用`enum`关键字来定义枚举类型，使用`::`来创建它的成员的实例。

枚举类型的实例可以直接附加数据，这样就可以不用额外的结构体把类型和数据结合到一起了。

枚举类型的成员可以是任意类型的数据，如字符串、数字类型、结构体、甚至是另一个枚举。如果用结构体来做，将会出现一堆结构体，没有枚举这样干净、清爽。

枚举类型也可以用`impl`关键字来定义方法。

`Option`是一个定义在Rust标准库中的枚举类型，其成员`Some`和`None`可以不需要前缀而直接使用。这个枚举类型说的是一个值只能有存在和不存在两种状态。其它语言中的空值`NULL`可能引发系统漏洞，而使用`Option`枚举则可方便rust编译器的检查，从而避免使用空值带来的不稳定因素。

```rust
enum Option<T> {
    Some(T),
    None,
}
```

##### match运算符

`match`把一个值和一系列模式相比较，并根据匹配到的模式执行相应的代码。其作用类似于C语言里的`switch`语句。

`match`的模块里用`=>`把模式和要运行的代码分开，每个分支之间用逗号分隔。

枚举类型的成员还可以是另一个枚举类型，这样`match`就可以枚举类型里的枚举类型了。

当`match`匹配`Option`枚举类型的时候，就可以对一个值有效和无效两种情况分别处理了。

`match`的匹配方式是穷尽式的，即所有可能的情况都必须列出来。如果有某些情况不想显式地列出来，可以用`_`模式来指代它们。感觉`_`模式类似于C语言`switch`语句的`default`选项。

##### if let控制流

如果只关心`match`里的一个分支，可用`if let`代替`match`以使代码在形式上简洁。

`if let`使用等号来分割模式和表达式。

#### 模块系统

控制复杂性的方法，就是把复杂问题拆分成多个简单的问题。一个大的程序是由多个更小一点的代码片断组成的，就像搭积木一样。Rust可以用的模块系统(积木)有：

- Crates - 完成自己独立功能的一些代码。我觉得大致可理解为用户写的用于实现特定功能的代码。
- 包 - 也是一些crate。它是用户的工具箱。
- 模块和use - 模块是对一个crate内部进行分组。`use`用于把路径引入作用域。
- 路径 - 

##### 包和crate

包的内容：

- Cargo.toml - 告诉rust编译器如何构建这个包。
- 作为库的crate - 只能有一个。如果存在的话即文件src/lib.rs，此时它是根crate。
- 二进制的crate - 可以有多个。如果存在src/main.rs，说明这是用户代码，此时它是根crate。

当src目录下lib.rs和main.rs同时出现，我觉得应该把main.rs视为根crate。

##### 模块

用`mod`关键字定义模块。模块里还可以包含模块。

模块之间形成树状的结构，树根叫`crate`(隐式的)，根crate即为`src/main.rs`或`src/lib.rs`。