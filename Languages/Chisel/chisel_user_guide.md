1. 介绍

   Chisel只是一些专门的**类定义**，预定义的**对象**，和对Scala**使用约定**的集合。所以，写Chisel程序实际上就是用Scala语言描述硬件。

   Chisel生成的是可综合的Verilog代码。Chisel也可以生成一个用C++实现的快速的、周期精确的RTL模拟器。

   Verilog和VHDL是作为硬件**模拟**语言而开发的，之后它们才成为硬件**综合**的基础。它们的大部分语义并不适合硬件综合，事实上大部分是不可综合的。而Chisel描述的直接就是可综合的电路，而且它更接近于Verilog这样低层次的硬件描述语言，而不是高层的综合系统。

2. 硬件表达

   本版本只支持二进制逻辑，不支持三态信号。

3. 数据类型

   - Bits:比特的原始组合
   - Sint:有符号整数
   - Uint:无符号整数
   - Bool:布尔值
   - Bundles:带有命名域的值的组合，类似于C语言里的结构体
   - Vecs:值的可索引的组合

4. 组合电路

   Chisel里的电路是结点组成的图。每个结点都是**硬件操作符**，由零或多个输入驱动一个输出。

   - &：按位与
   - |：按位或
   - ~：按位非

   简单表达式可以直接转换为电路树，在叶子和操作符上形成内部结点。表达式的最终输出是从树根上的操作符提取出来的。

   - val:用来命名值不会再变化的变量

   Chisel也支持**电线**作为结点，可用来赋值或连接到其它结点。

   - Wire:电线

5. 内置操作符

   - 按位操作符：~， &， `(overflow)，^
   - 按位归约：andR, orR, xorR
   - 相等比较：===, =/=
   - 移位：<<, >>
   - 位域操作：x(), Fill(), Cat()
   - 逻辑运算：! && ` Mux()
   - 算术运算：+ +% +& - -% -& * / %
   - 算术比较：> >= < <=

6. 功能抽象

   我们可以定义函数来提取出重复的逻辑，在一个设计里重复使用。

   - 定义函数：def

7. Bundles和Vecs

   Bundles和Vecs是使用户可以扩展数据类型的类。Bundle相当于C语言里的结构体，Vec相当于数组。

8. 端口

   端口是硬件组件之间的接口。基本端口Input和Output可以合成更复杂的端口。

9. 模块

   Chisel的模块非常类似于在生成的电路中定义层次结构的Verilog模块。

   用户定义的模块被定义为如下的类：

   - 继承自Module
   - 包含封装在模块IO方法的接口
   - 存储在一个名为io的端口字段中
   - 在其构造函数中连接子电路

10. 黑箱

  Chisel的黑盒用来表示外部定义的模块。

11. 状态元素

    最简单的状态元素是正边沿触发寄存器，可表示如下：

    `val reg = RgeNext(in)`

    此电路的输出是延迟一个时钟周期后输入信号in的复制。

    计数器是重要的时序电路。

12. 内存

    - ROM

      用户可通过Vec定义只读内存

    - MEM

    - Masks

13. 接口与bulk连接

    - 端口：子类与嵌套
    - Bundle Vectors
    - Bulk Connections

14. 功能模块创建

15. Mux与输入选择

    - Mux：2-输入选择器
    - MuxCase：多路选择器
    - MuxLookup：可索引多路复用器
    - Mux1H：接收一系列选择器和值，返回与被设置的选择器相关联的值。

16. 多态与参数化

    此部分是高级的，可在第一次阅读时跳过。

17. 多时钟域

18. 注解：扩展Chisel和Firrtl

    使用import引用我们需要的组件。

    Write a transform

    创建一个注解工厂

    创建一个注解器

    使用注解器

19. 运行时发生了什么？

    执行模式

    运行用scala写的chisel代码

    执行模式的层次

    执行模式代码

    所有的选项

20. Chisel3 vs Chisel2

21. 致谢