#### wait, waitpid, waitid

等待子进程状态改变

```c
pid_t wait(int *wstatus);
// 只要有一个子进程终止就不再等待。相当于waitpid(-1, wstatus, 0).
// 返回值：成功则返回子进程id，错误返回-1。
// wstatus : NULL，则忽略。非NULL,则用于保存子进程的状态信息。

pid_t waitpid(pid_t pid, int *wstatus, int options);
// 只有给定子进程pid状态改变才不再等待。
// 返回值：成功则返回子进程id，错误返回-1，某些情况下返回0.
// pid : 小于-1则所等待的子进程的组id要等于|pid|，
//       等于-1则等待任意子进程即可，
//       等于0所等待的子进程的组id要等于父进程，
//       大于0则所等待的子进程的id要等于pid。
// optons : 所等待的子进程的状态。
//		WNOHANG : 无子进程退出。
//		WUNTRACED : 
//		WCONTINUED : 

int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
// 提供更精确的控制
// 返回值：成功返回0，错误返回-1。
// idtype : P_PID , 所等待的子进程的进程号为id。
//		P_PGID , 所等待的子进程的组id为id。
//		P_ALL , 等待任意子进程，此时忽略id。
struct siginfo_t {
    pid_t si_pid;	// 子进程的id
    uid_t si_uid;	// 子进程的用户id
    int	si_signo;	// 
    int si_status;	// 
    int si_code;	// 
}
// options : WEXITED
//		WSTOPPED
//		WCONTINUED
//		WNOHANG
//		WNOWAIT

pid_t wait3(int *wstatus, int options, struct rsuage *rusage);
// 返回值 ： 与waitpid相同。
// rusage : NULL则忽略，非NULL则保存子进程的统计信息。
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);
// 返回值： 与waitpid相同。
```



#### gettimeofday

获取从1970-01-01 00:00:00 +0000(UTC)到现在经历的时间。这个时间记录在`TimeVal`中。

```c
ing gettimeofday(struct timeval *tv, int timezone)
struct timeval {
    time_t sec;			// 秒数
    suseconds_t usec;	// 微秒数
}
```

