### 文件/外设

#### access, faccessat

检查用户对一个文件的权限

#### close

关闭文件描述符

#### dup, dup2, dup3

复制文件描述符

#### fcntl

管理文件描述符

#### getcwd, getwd, get_current_dir_name

获取当前工作目录

#### ioctl

控制设备

```c
/*
 * 通过控制设备文件来控制设备。特别是字符设备，如终端(teminals)。
 * fd : 设备文件的文件描述符，要求设备文件必须是打开的。
 * request : 依赖于设备的请求码。关于此参数的宏和定义在<sys/ioctl.h>。
 *   TCGETS : 获取当前串口设置(Tty Ctrl GET Serial port Settings)
 *   TIOCGPGRP : 获取终端上进程的组ID(Tty IO Ctrl Get the Process GRouP id)
 * 第三个参数：无类型(untyped)的指针，它是char *argp。
 * 返回值：非负表示成功，负数表示失败。
 *   EBADF : fd无效。
 *   EFAULT : argp引用了不可访问的内存区域。
 *   EINVAL : request或argp无效。
 *   ENOTTY : fd没有关联到字符设备。
 */
int ioctl(int fd, unsigned long request, ...);
```



#### lseek

重新定位读/写文件的位移

#### open, openat, creat

打开或创建文件

#### read

从文件描述符读

#### stat,fstat,lstat,fstatat

获取文件状态

#### umask

设置文件模式的掩码

### 进程

#### arch_prctl

设置特定架构的线程状态

#### clone, __clone2

创建子进程

```c
/* 类似于fork()。与fork()不同的是，clone()出来的子进程可以共享父进程的部分上下文，如虚拟地址空间、文件描述符表、信号句柄的表(table of signal handlers)。
 * clone()的一个作用是创建线程，多个线程可以共享地址空间。
 * fn : 函数的标记，子进程从此处开始执行。而fork()出来的子进程是从调用点开始执行的。
 * child_stack : 指定子进程的栈。由于栈是向下增长的，所以此参数应指向栈的高地址。
 * 当函数fn(arg)返回时，子进程终止。fn的返回值即为子进程的退出状态。子进程也可以调用exit()终止，或接收到fatal信号后终止。
 * flags :
 * arg : 函数fn的参数。
 */
int clone(int (*fn)(void *), void *child_stack, int flags, void *arg, ...);

```

#### execve

执行程序

#### getgid, getegid

获得调用进程的组ID

#### getgroups, setgroups

获取、设置所附加组ID的列表

#### getpgid, getpgrp

获得进程的组

#### getpid, getppid

获取进程ID

#### getpriority, setpriority

获取、设置调度优先级

#### getresuid, getresgid

获取真实(r)有效(e)已保存的(s)用户ID、组ID

#### getsid

获取会话(session)ID

#### getuid, geteuid

获得调用进程的用户ID

#### pipe, pipe2

创建管道

#### prctl

对进程的操作

#### setgid

设置组ID

#### setpgid, setpgrp

设置进程的组

#### setresuid, setresgid

设置真实(r)有效(e)已保存的(s)用户ID、组ID

#### setsid

创建会话并设置进程组ID

#### setuid

设置用户ID

#### sched_setaffinity, sched_getaffinity

设置、获取线程对CPU的亲和力掩码(affinity mask)

#### sched_setparam, sched_getparam

设置、获取调度参数

#### sched_setscheduler, sched_getscheduler

设置、获取调度策略

#### sched_yield

让出处理器

#### times

获取进程相关的一些时间

#### wait, waitpid, waitid

等待子进程状态改变

```c
pid_t wait(int *wstatus);
// 只要有一个子进程终止就不再等待。相当于waitpid(-1, wstatus, 0).
// 返回值：成功则返回子进程id，错误返回-1。
// wstatus : NULL，则忽略。非NULL,则用于保存子进程的状态信息。

pid_t waitpid(pid_t pid, int *wstatus, int options);
// 只有给定子进程pid状态改变才不再等待。
// 返回值：成功则返回子进程id，错误返回-1，某些情况下返回0.
// pid : 小于-1则所等待的子进程的组id要等于|pid|，
//       等于-1则等待任意子进程即可，
//       等于0所等待的子进程的组id要等于父进程，
//       大于0则所等待的子进程的id要等于pid。
// optons : 所等待的子进程的状态。
//		WNOHANG : 无子进程退出。
//		WUNTRACED : 
//		WCONTINUED : 

int waitid(idtype_t idtype, id_t id, siginfo_t *infop, int options);
// 提供更精确的控制
// 返回值：成功返回0，错误返回-1。
// idtype : P_PID , 所等待的子进程的进程号为id。
//		P_PGID , 所等待的子进程的组id为id。
//		P_ALL , 等待任意子进程，此时忽略id。
struct siginfo_t {
    pid_t si_pid;	// 子进程的id
    uid_t si_uid;	// 子进程的用户id
    int	si_signo;	// 
    int si_status;	// 
    int si_code;	// 
}
// options : WEXITED
//		WSTOPPED
//		WCONTINUED
//		WNOHANG
//		WNOWAIT

pid_t wait3(int *wstatus, int options, struct rsuage *rusage);
// 返回值 ： 与waitpid相同。
// rusage : NULL则忽略，非NULL则保存子进程的统计信息。
pid_t wait4(pid_t pid, int *wstatus, int options, struct rusage *rusage);
// 返回值： 与waitpid相同。
```

#### wait3,wait4

BSD风格的wait

### 内存

#### brk, sbrk

改变数据段的大小

#### mmap,munmap

把文件或设备映射(或取消映射)到内存

#### mprotect, pkey_mprotect

设置对一个内存区域的保护

### 信号

#### kill

向进程发送信号

#### sigaction, rt_sigaction

检测并改变一个信号的行为

#### sigaltstack

设置、获取信号栈的上下文

#### sigprocmask, rt_sigprocmask

检测并改变被阻塞的信号

#### sigreturn, rt_sigreturn

从信号handler返回，并清空stack frame

#### sigsuspend, rt_sigsuspend

等待一个信号

#### sigwaitinfo, sigtimedwait, rt_sigtimedwait

同步等待排队的信号

#### tkill, tgkill

向线程发信号

### 计时器

#### clock_getres, clock_gettime, clock_settime

时钟和时间的函数

#### clock_nanosleep

可指定时钟的高精度睡眠(high-resolution sleep with specifiable clock)

#### getitimer, setitimer

获取、设置间隔计时器(interval timer)的值

#### gettimeofday

获取从1970-01-01 00:00:00 +0000(UTC)到现在经历的时间。这个时间记录在`TimeVal`中。

```c
ing gettimeofday(struct timeval *tv, int timezone)
struct timeval {
    time_t sec;			// 秒数
    suseconds_t usec;	// 微秒数
}
```

#### settimeofday

设置时间。

### 网络

#### connect

在socket上发起一个连接

#### socket

创建通信的端点

### 其它

#### gethostname, sethostname

获取、设置hostname

#### reboot

重启系统

#### sysinfo

获取系统信息

#### syslog, klogctl

read and/or clear kernel message ring buffer; set console_loglevel

#### uname

获取内核信息
