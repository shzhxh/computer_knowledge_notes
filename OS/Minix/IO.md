

#### Minix3中的I/O

##### 中断处理例程和I/O访问

用户空间的驱动程序需要不同的I/O访问类型，这些都需要系统任务通过使用内核调用来进行支持。

1. 访问它自己数据空间以外的内存。比如内存驱动程序。
2. 读写I/O端口。比如硬盘驱动程序。
3. 响应可预测的中断。比如硬盘驱动程序向硬盘控制器写入命令。
4. 响应不可预测的中断。比如键盘驱动程序。

对于第一种情况，需要系统任务使用Intel处理器的硬件分段机制。通过系统任务，内存驱动程序就可以访问它所需要的内存区域，控制台驱动程序则可访问视频显示适配器(VDA)的内存。

对于第二种情况，则需要系统任务通过内核调用来使用I/O指令。

第三种情况的过程是。当用户空间的程序通过`sys_irqctl`内核调用初始化一个中断，中断处理例程总是`generic_handler`，这一在系统任务里定义的函数。此例程把中断转化为通知消息。内核调用把命令发给控制器，然后设备驱动程序初始化一个`receive`操作。设备驱动程序收到通知后继续做接下来的事。

第四种情况的问题是。比如tty驱动程序，它支持多种设备，所以有多个进程和它交互。所以不能为个单个源的输入，而阻塞`receive`调用。Minix3使用了多种技术来处理此问题。

##### 设备驱动程序

每种I/O设备都对应一个设备驱动程序，这些驱动程序都是完整的进程。一个简单的设备驱动程序会放在单个的源文件里。

磁盘设备组：RAM盘，硬盘，软盘都对应着单一的源文件。而支持块设备的通用例程则放在`driver.c`和`drvlib.c`。`driver.h`用于支持所有的块设备。

终端设备组：内存映射控制台，键盘，串口，伪终端都对应着单一的源文件。硬件无关的部分则放在`tty.c`。这样，单个的进程就可以支持上述这此设备了。`tty.h`提供了所有终端设备的通用定义。

块设备请求消息里的字段：

```
int m.m_type	// 所请求的操作
int m.DEVICE	// 使用的次设备
int m.PROC_NR	// 哪个进程的请求
int m.COUNT		// 字节数或ioctl码
long m.POSITION	// 设备里的位置
char* m.ADDRESS	// 发出请求的那个进程的缓冲区地址，用于保存要收发的数据
```

块设备回复消息里的字段：

```
int m.m_type		// 总是DRIVER_REPLY
int m.REP_PROC_NR	// 即请求消息里的PROC_NR
int m.REP_STATUS	// 传送的字节数或错误号
```

字符设备用到的字段类似于块设备，但不同字符设备之间有轻微的不同。

块设备驱动程序是严格顺序执行的，当发出硬件请求后，驱动程序就执行`receive`操作，这意思着它只接收中断消息不再接收新的请求。终端驱动程序则不是这样，因为一个终端驱动程序服务着多个设备。

##### 设备无关的I/O软件

所有设备无关的I/O都包含在文件系统进程里。

##### 用户级I/O软件

- 库例程，如`printf`和`scaonf`。
- 一个多任务缓冲守护进程`lpd`，通过`lp`命令缓冲和打印文件。
- 支持各种网络功能的大量守护进程。
- 网络服务进程，内存管理进程，文件系统进程。

##### 死锁的处理

Minix3里直接忽略了死锁的问题。

Minix3里的某些设计可以避免死锁。最主要的是进程间消息传递的设计。

还有`notify`消息原语的设计也可以避免死锁。

锁的机制也可以避免死锁。

##### RAM盘

内存驱动程序用来访问内存的任意部分。RAM盘驱动程序属于内存驱动程序，它保留一部分内存当传统硬盘来用。

RAM硬盘的思想就是在内存里保存块，可以快速的访问经常使用的数据。

对于支持挂载的系统，一旦挂载完成，用户就不必考虑文件在哪个设备上。

对于不支持挂载的系统，用户必须显式地指定文件的位置。对于拥有几十个磁盘的大型系统这将是个灾难。

RAM盘也是由块组成的。当向驱动程序发出消息要读或写一个块的时候，它计算出块的位置直接在内存里读或写。最终通过系统任务调用`phys_copy`实现内存间复制。

一个RAM盘驱动程序可以支持多个RAM盘，这些RAM盘之间通过次设备号来区分。RAM盘的空间一般应该是分开的，但也可以重叠。

##### 硬盘驱动程序概述

Minix把不同的硬盘驱动程序都放进了启动镜像，由用户决定来用哪个。

用户通过向引导监控程序输入参数`albel = AT`强制让Minix3使用IDE磁盘控制器(at_wini)。

硬盘驱动程序的主循环支持9种请求。

- DEV_OPEN
- DEV_CLOSE
- DEV_IOCTL
- DEV_READ, DEV_WRITE, DEV_GATHER, DEV_SCATTER
- DEV_CANCEL. DEV_SELECTE：被忽略。

##### 键盘驱动程序

POSIX要求标准库中的一些函数可以让程序来控制终端参数，基中最重要的两个是`tcgetattr()`和`tcsetattr()`。它们读写`termios`结构体，`termios`结构体包含了关于终端的所有信息。Minix3提供了`ioctl()`系统调用来支持这两个函数。

```c
struct termios {
tcflag_t c_iflag; /* 存放影响输入的位 */
    // ICRNL位可以让输入的CR字符转成NL字符
tcflag_t c_oflag; /* 存放影响输出的位 */
    // OPOST位使能输出
    // ONLCR位可以输出的NL字符转成 CR NL 序列
tcflag_t c_cflag; /* control modes */
    // Minix3默认使能一条线路接收8位字符，用户登出这条线路则modem挂起。
tcflag_t c_lflag; /* local modes */
    // ECHO位使能回显
    // ICANON位使能规范模式。
    // 其它位如果都是默认设置，则进到传统的"cbreak mode"，输入字符不等满行就传给了程序。
speed_t c_ispeed; /* input speed */
speed_t c_ospeed; /* output speed */
cc_t c_cc[NCCS]; /* 存放可以改变的特殊字符 */
};

/*
 * request：对termios结构体是读还是写
 * argp：指向termios结构体的指针
 */
ioctl(file_descriptor, request, argp);
```

