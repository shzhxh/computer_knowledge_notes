

#### Minix3中的I/O

##### 中断处理例程和I/O访问

用户空间的驱动程序需要不同的I/O访问类型，这些都需要系统任务通过使用内核调用来进行支持。

1. 访问它自己数据空间以外的内存。比如内存驱动程序。
2. 读写I/O端口。比如硬盘驱动程序。
3. 响应可预测的中断。比如硬盘驱动程序向硬盘控制器写入命令。
4. 响应不可预测的中断。比如键盘驱动程序。

对于第一种情况，需要系统任务使用Intel处理器的硬件分段机制。通过系统任务，内存驱动程序就可以访问它所需要的内存区域，控制台驱动程序则可访问视频显示适配器(VDA)的内存。

对于第二种情况，则需要系统任务通过内核调用来使用I/O指令。

第三种情况的过程是。当用户空间的程序通过`sys_irqctl`内核调用初始化一个中断，中断处理例程总是`generic_handler`，这一在系统任务里定义的函数。此例程把中断转化为通知消息。内核调用把命令发给控制器，然后设备驱动程序初始化一个`receive`操作。设备驱动程序收到通知后继续做接下来的事。

第四种情况的问题是。比如tty驱动程序，它支持多种设备，所以有多个进程和它交互。所以不能为个单个源的输入，而阻塞`receive`调用。Minix3使用了多种技术来处理此问题。

##### 设备驱动程序

每种I/O设备都对应一个设备驱动程序，这些驱动程序都是完整的进程。一个简单的设备驱动程序会放在单个的源文件里。

磁盘设备组：RAM盘，硬盘，软盘都对应着单一的源文件。而支持块设备的通用例程则放在`driver.c`和`drvlib.c`。`driver.h`用于支持所有的块设备。

终端设备组：内存映射控制台，键盘，串口，伪终端都对应着单一的源文件。硬件无关的部分则放在`tty.c`。这样，单个的进程就可以支持上述这此设备了。`tty.h`提供了所有终端设备的通用定义。

块设备请求消息里的字段：

```
int m.m_type	// 所请求的操作
int m.DEVICE	// 使用的次设备
int m.PROC_NR	// 哪个进程的请求
int m.COUNT		// 字节数或ioctl码
long m.POSITION	// 设备里的位置
char* m.ADDRESS	// 发出请求的那个进程的缓冲区地址，用于保存要收发的数据
```

块设备回复消息里的字段：

```
int m.m_type		// 总是DRIVER_REPLY
int m.REP_PROC_NR	// 即请求消息里的PROC_NR
int m.REP_STATUS	// 传送的字节数或错误号
```

字符设备用到的字段类似于块设备，但不同字符设备之间有轻微的不同。

块设备驱动程序是严格顺序执行的，当发出硬件请求后，驱动程序就执行`receive`操作，这意思着它只接收中断消息不再接收新的请求。终端驱动程序则不是这样，因为一个终端驱动程序服务着多个设备。

##### 设备无关的I/O软件

所有设备无关的I/O都包含在文件系统进程里。

##### 用户级I/O软件

- 库例程，如`printf`和`scaonf`。
- 一个多任务缓冲守护进程`lpd`，通过`lp`命令缓冲和打印文件。
- 支持各种网络功能的大量守护进程。
- 网络服务进程，内存管理进程，文件系统进程。

##### 死锁的处理

Minix3里直接忽略了死锁的问题。

Minix3里的某些设计可以避免死锁。最主要的是进程间消息传递的设计。

还有`notify`消息原语的设计也可以避免死锁。

锁的机制也可以避免死锁。

#### RAM盘驱动程序

内存驱动程序用来访问内存的任意部分。RAM盘驱动程序属于内存驱动程序，它保留一部分内存当传统硬盘来用。

RAM硬盘的思想就是在内存里保存块，可以快速的访问经常使用的数据。

对于支持挂载的系统，一旦挂载完成，用户就不必考虑文件在哪个设备上。

对于不支持挂载的系统，用户必须显式地指定文件的位置。对于拥有几十个磁盘的大型系统这将是个灾难。

RAM盘也是由块组成的。当向驱动程序发出消息要读或写一个块的时候，它计算出块的位置直接在内存里读或写。最终通过系统任务调用`phys_copy`实现内存间复制。

一个RAM盘驱动程序可以支持多个RAM盘，这些RAM盘之间通过次设备号来区分。RAM盘的空间一般应该是分开的，但也可以重叠。

#### 硬盘驱动程序

Minix把不同的硬盘驱动程序都放进了启动镜像，由用户决定来用哪个。

用户通过向引导监控程序输入参数`albel = AT`强制让Minix3使用IDE磁盘控制器(at_wini)。

硬盘驱动程序的主循环支持9种请求。

- DEV_OPEN
- DEV_CLOSE
- DEV_IOCTL
- DEV_READ, DEV_WRITE, DEV_GATHER, DEV_SCATTER
- DEV_CANCEL. DEV_SELECTE：被忽略。

#### 终端驱动程序

终端驱动程序构成了Minix3中最大的驱动程序。终端驱动程序即要处理键盘和显示器，还要处理两种可选的终端。

终端驱动程序接收的消息类型有：

1. 用户进程通过FS读终端。

2. 用户进程通过FS写终端。

   读写的消息和块设备的消息有相同的格式。

3. 用户进程通过FS设置终端的参数。

   一般应使用POSIX函数间接调用`ioctl`，若POSIX不支持则只能直接调用`ioctl`。

4. 当按下或释放键的时候，发生键盘中断。

5. 当信号产生的时候，FS取消之前的请求。

6. 打开设备。

7. 关闭设备。

8. 其它特殊用途的消息。

Minix3可以支持最高8个虚拟终端，这样用户就可以通过登陆不同的终端，在多个显示输出和键盘输入之间切换。可以按ALT+Fn切换虚拟控制台，也可以用ALT+方向键切换虚拟控制台。此外，串行线可以支持远程连接，伪终端可以支持网络连接。

POSIX要求标准库中的一些函数可以让程序来控制终端参数，基中最重要的两个是`tcgetattr()`和`tcsetattr()`。它们读写`termios`结构体，`termios`结构体包含了关于终端的所有信息。Minix3提供了`ioctl()`系统调用来支持这两个函数。

```c
struct termios {
tcflag_t c_iflag; /* 存放影响输入的位 */
    // ICRNL位可以让输入的CR字符转成NL字符
tcflag_t c_oflag; /* 存放影响输出的位 */
    // OPOST位使能输出
    // ONLCR位可以输出的NL字符转成 CR NL 序列
tcflag_t c_cflag; /* control modes */
    // Minix3默认使能一条线路接收8位字符，用户登出这条线路则modem挂起。
tcflag_t c_lflag; /* local modes */
    // ECHO位使能回显
    // ICANON位使能规范模式。
    // 其它位如果都是默认设置，则进到传统的"cbreak mode"，输入字符不等满行就传给了程序。
speed_t c_ispeed; /* input speed */
speed_t c_ospeed; /* output speed */
cc_t c_cc[NCCS]; /* 存放可以改变的特殊字符 */
};

/*
 * request：功能请求码，对termios结构体是读还是写
 * argp：指向termios结构体的指针
 */
ioctl(file_descriptor, request, argp);
```

##### 从键盘输入到应用程序的流程

当用户在系统控制台上登陆，会创建一个shell，并把`/dev/console`作为标准输入、标准输出和标准错误。shell调用库例程`read`来从标准输入读数据。`read`向文件系统发消息，消息包含了文件描述符，缓冲区地址，字节数。发完消息后，shell阻塞，等待回复。

文件系统接收到`read`发过来的消息，并定位到文件描述符所对应的索引节点(i-node)。这个索引节点对应着`/dev/console`，包含了终端的主、次设备号。终端的主设备号是4,控制台的次设备号是0。

文件系统通过检索设备映射dmap来找到终端驱动程序TTY的编号。然后向TTY发消息。一般来说用户还没有任何输入，所以终端驱动程序不能满足此请求。终端驱动程序立即发送一个回复以解除文件系统的阻塞。文件系统在控制台的结构体`tty_table`里记录下有一个进程在等待终端输入，然后就处理下一个工作请求。用户的shell则会一直阻塞，直到请求的字符抵达。

当键盘输入最终发生时，会产生两个中断，一个是键被按下时产生，一个是键被释放时产生。需要注意的是键盘生成的不是ASCII码，而是**扫描码**(scan code)。同一个键扫描码的低7位是相同的，最高位按下是0，释放是1。

键盘中断是IRQ 1。此中断线无法在系统总线上访问，也不能被其它I/O适配器共享。当`_hwint01`调用`intr_handle`，要通知的TTY会被很快找到。低层的中断处理例程通过直接调用系统任务里的`generic_handler`发出通知消息。`tty_task`接收到`HARD_INT`消息后就分发给`kbd_interrupt`，`kbd_interrupt`再调用`scan_keyboard`。`scan_keyboard`进行了3个内核调用让系统调用读写若干 I/O端口，最终得到扫描码，并把扫描码放到循环缓冲区中。然后设置`tty_events`标志，表示此缓冲区包含字符不再为空。
