### 参考

[理解安卓build系统](https://www.ibm.com/developerworks/cn/opensource/os-cn-android-build/)

### source build/envsetup.sh

初始化编译环境，并引入一些辅助命令。

- 1~29, hmm, 加载编译时使用的命令。

- 214~222, printconfig, 显示当前构建的配置信息。

- 439~460, add_lunch_combo, 用来给lunch命令添加编译选项。

  脚本里添加了6条选项：

  ```
  add_lunch_combo aosp_arm-eng
  add_lunch_combo aosp_arm64-eng
  add_lunch_combo aosp_mips-eng
  add_lunch_combo aosp_mips64-eng
  add_lunch_combo aosp_x86-eng
  add_lunch_combo aosp_x86_64-eng
  ```

- 659~668, m, 在源码树的根目录执行make

- 687~723, mm, 构建当前目录下的模块

- 725～770， mmm, 构建指定目录下的模块

- 823～831，croot，切换到源码树的根的目录

- 1329~1332, jgrep, 在所有java文件上执行grep

- 1334~1337, cgrep, 在所有c/c++文件上执行grep

- 1339~1342, resgrep, 在所有res/*.xml文件上执行grep

- 1590~1632, godir, 转到包含某个文件的目录路径

- 1738~1747，在文件的末尾，查找vendorsetup.sh脚本并加载它。

  可以单独运行find命令找到这些脚本的位置，它们在device/generic/x86/vendorsetup.sh和device/generic/x86_64/vendorsetup.sh。它们只有3条命令，以device/generic/x86/vendorsetup.sh为例：

  ```
  add_lunch_combo android_x86-eng
  add_lunch_combo android_x86-userdebug
  add_lunch_combo android_x86-user
  ```


### lunch

lunch命令定义在build/envsetup.sh里，用来让用户选择编译设备与编译类型。其执行步骤如下：

1. 定义变量answer，如果命令里给了参数则直接使用给定的参数，否则列出所有的编译选项让用户选项。

2. 定义变量selection，如果用户没选择则使用默认选项aosp_arm-eng，如果用户输入的是数字则使用该数字对应的字符串，如果用户输入的是字符串则直接使用该字符串。

3. 定义变量product，将selection里"-"的前面部分放在变量product里，调用check_product函数检查之。

4. 定义变量variant，将selection里"-"的后面部分放在变量variant里，调用check_variant函数检查之。

5. 定义如下3个环境变量

   ```
   export TARGET_PRODUCT=$product
   export TARGET_BUILD_VARIANT=$variant
   export TARGET_BUILD_TYPE=release
   ```

6. set_stuff_for_environment函数，设置一些环境变量。

7. printconfig函数，打印一些主要的变量。

### make

如果没有指定编译目标，则使用默认目标**droid**，该目标会编译出完整的安卓镜像。

构建的起点在`build/core/main.mk`

```
49 include $(BUILD_SYSTEM)/config.mk		# 定义基于配置和宿主信息的变量
86 include $(BUILD_SYSTEM)/cleanbuild.mk	# 定义删除编译结果的函数和目标
133 include $(BUILD_SYSTEM)/definitions.mk	# 定义编译过程中用到的变量和宏
138~283		# 检查TARGET_BUILD_VARIANT变量有效性
根据make参数决定编译目标
加载所有子目录下的Android.mk
从Android.md中筛选出TARGET_BUILD_VARIANT目标
包含Makefile
930~1183 定义一些目标
```

编译目标oto_img在bootable/newinstaller/Android.mk

```
# 1. 从175行可见，OTO_IMAGE即oto_img
	oto_img: $(OTO_IMAGE)
# 2. OTO_IMAGE详见143~158行
	$PRODUCT是out/target/product/openthos/
```



#### build系统核心文件

位于`build/core`目录下

#### 针对具体产品的makefile

通常位于`device`目录下

#### 针对某个模块的makefile

这类文件的名称都叫做`Android.mk`

### 编译出的结果

在`out`目录下

### 编译错误记录

>   DEPMOD  4.9.109-android-x86_64-01316-g45b3cc90-dirty
>
> /root/szx/kernel/Makefile:1350: recipe for target '_modinst_post' failed
> make[1]: *** [_modinst_post] Error 255
> make[1]: Leaving directory '/root/szx/out/target/product/openthos/obj/kernel'
> Makefile:152: recipe for target 'sub-make' failed
> make: *** [sub-make] Error 2
> make: Leaving directory '/root/szx/kernel'
> [ 99% 99776/99781] build out/target/product/openthos/install.img
> ninja: build stopped: subcommand failed.
> 02:44:29 ninja failed with: exit status 1

问题分析：我的情况是少了kmod，把它安装上即可。`sudo apt install kmod`。另，还应检查`syslinux  genisoimage   gettext   bc  dosfstools   mtools   kmod`是否都安装齐全。另：从这里是看不出来问题在哪的，要从往前翻，找到真正错误的地方。