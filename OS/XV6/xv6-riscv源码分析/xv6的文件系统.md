#### 概述

文件系统看起来更像是一种约定，约定的是数据在磁盘上的存储形式。磁盘上的文件系统是自恰的，即包含了全部的信息，所以任何操作系统都可以读取到它。操作系统依据这个约定来管理磁盘上的信息，所以操作系统里的那个“文件系统”应该叫文件管理系统，或者说是文件系统的软件层面。

xv6-public和xv6-riscv所用的文件系统差别很小，唯一的差别就在于xv6-riscv的超级块里增加了一个标示自己的魔数。这点差别是微不足道的，对于软件层面的操作几乎没有影响。但在文件管理系统的实现上，xv6-public和xv6-riscv就有比较明显的差别了。虽然它们都划分了七层，但xv6-public是上了一个大锁，而xv6-riscv是真正的多核并行，所以在每层的实现上xv6-riscv都多了些锁的结构。

所以，本文要说的是文件管理系统，但在说明白文件管理系统之前，先要说明白磁盘上的文件系统。

| 每层名称     | 对应文件          | 核心变量 |
| ------------ | ----------------- | -------- |
| 硬盘层       | virtio_disc.c     |          |
| 缓冲区缓存层 | bio.c             | bcache   |
| 日志层       | log.c             | log      |
| 索引结点层   | fs.c              | icache   |
| 目录层       | fs.c              |          |
| 路径名层     | fs.c              |          |
| 文件描述符层 | file.c, sysfile.c |          |

硬盘层的代码在，缓冲区缓存层的代码在，日志层的代码在

#### 零、磁盘上的文件系统

磁盘整体上可以分为三个部分。

1. 第一个部分是启动块。它占用一个块的大小，不属于文件系统的一部分。
2. 第二个部分存放的是元数据，具体又可以分为四个区。它占用少量的块，是文件系统的一部分。
   - 超级块：记录了整个文件系统的基本信息。是其它三个区的索引。占用一个块。
   - 日志区：用于保证硬件层面和软件层面的一致性。占用30个块，本区内第一个块是本区内其它块的索引，本区内其它块是记录了具体信息的块。
   - 索引结点区：一个索引结点就是一个文件。占用13个块，最多可以存放200个索引结点。每个索引结点都是对用户数据的索引，采用一级和二级混合索引的方式，可知文件最大不能超过268KB（12+1024/4 个块）。
   - 位图区：对用户数据里空闲块的索引。占用1个字节。
3. 第三个部分存放的是用户数据。它占用了大量的块，是文件系统的一部分。整个镜像给指定的块数是1000，那么这部分的块数就是954（1000－46）。

#### 一、硬盘层

硬盘层实际上就是磁盘驱动程序。

它向缓冲区缓存提供的接口是`virtio_disk_rw`。

- 作用：在缓冲区和磁盘之间交换数据。

- `*b`：缓冲区的指针
- `write`：1把缓冲区的内容写入到磁盘，0把磁盘的内容读取到缓冲区

#### 二、缓冲区缓存层

缓冲区缓存(buffer cache)是一个双向链表的结构，链表里的每一个结点都代表一个缓冲区(buffer)。上层文件系统要读磁盘的一个块，先要把块的内容保存到缓冲区，再从缓冲区读出来。上层文件系统要写磁盘的一个块，先要写缓冲区，再把缓冲区的内容写到磁盘上。

上层可能用到如下接口：

`bread`

- 作用：为给定的扇区分配缓冲区，并且把扇区的内容读取到缓冲区。如果那个扇区的内容已经被缓存，则直接返回对应缓冲区的指针。如果那个扇区的内容还没有被缓存，则从缓冲区缓存里找一个引用计数为0的缓冲区返回。
- `dev`：设备号
- `blockno`：块号

`bwrite`

- 作用：把缓冲区的内容写入到磁盘。
- `*b`：缓冲区的指针。

`brelse`

- 作用：给定缓冲区的引用计数减1。当引用计数为0时把这个缓冲区从双向链表中删除，再把它插入到链表头的前面。这样做的好处是，当双向链表向后查时都是在用的缓冲区，当双向链表向前查时都是空闲的缓冲区。
- `*b`：缓冲区的指针。

#### 三、日志层

日志层是为了解决系统崩溃后，磁盘上的文件系统一致性被破坏的问题。它的思想是在磁盘上建立一个日志区，所有对磁盘的写操作先写到日志区，然后再把日志区的数据写到数据区。如果在写日志区的时候系统崩溃了，那么系统重启后什么都不做；如果在日志区写数据区的时候崩溃了，系统会重新执行一遍日志区写数据区的工作。这样就保证了磁盘上文件系统的一致性。

日志层里的函数是要结合起来用的，一次事务用`begin_op`开头，用`end_op`结尾，中间是对磁盘的操作。

上层可能用到如下接口：

`begin_op`

- 作用：给`log.outstanding`执行加1操作，以表示日志区被引用了1次
- 没有参数，没有返回值

`end_op`

- 作用：给`log.outstanding`执行减1操作。如`log.outstanding`为0则调用`commit`把一次事务写入磁盘。
- 没有参数，没有返回值

`log_write`

- 作用：如果指定的缓冲区没有和日志区里的日志块建立对应关系，则对其引用记数加1。否则，什么都不做。
- `*b`：缓冲区的指针
- 返回值(void)

#### 四、索引结点层

到了这一层终于有文件的概念了，一个索引结点其实就对应了一个文件。索引结点(inode)的英文原意应该是index node，它是把属于同一个文件的所有的块索引到一起而形成一个结点。有两种类型的索引结点：磁盘上的索引结点对应的数据结构是`dinode`，文件管理系统里的索引结点对应的数据结构是`inode`。

上层可能用到如下接口：

`ialloc`

- 作用：分配一个新的`inode`
- `dev`：设备号
- `type`：文件类型。1目录，2文件，3设备。
- 返回值(`struct inode *`)：新分配的`inode`的指针
- 执行过程：遍历磁盘上索引结点区，查找type值为0的索引结点（表明它是空闲的），调用iget函数分配指针。

`iget`

- 作用：请求一个到`inode`的指针
- `dev`：设备号
- `inum`：磁盘上索引结点在索引区的编号
- 返回值(`struct inode *`)：请求到的`inode`的指针
- 执行过程：首先会在`icache`里遍历所有的`inode`，如果请求的`inode`已经缓存在里面则直接返回，同时会找一个引用计数为0的`inode`，如果还没有缓存，就把引用计数为0的那个`inode`初始化后返回。

`iput`

- 作用：释放一个到`inode`的指针
- `*ip`：准备释放的指针
- 返回值(void)
- 执行过程：如果这个指针引用计数为1，也没有到它的连接，则执行释放的过程。否则，仅执行引用计数减1的操作。

`readi`

- 作用：从`inode`里读取数据
- `*ip`：索引结点的指针，就是从这个索引结点读取数据的
- `user_dst`：1索引结点的数据是要复制到用户空间，0索引结点的数据是要复制到内核空间
- `dst`：目标地址，用于保存从索引结点读取的数据
- `off`：要读取的数据在索引结点里的位置
- `n`：要读取的数据有多少个字节
- 返回值(int)：实际读取了多少个字节
- 执行过程：把索引结点里的数据逐块的复制到目标地址

`writei`

- 作用：向`inode`里写入数据
- `*ip`：索引结点的指针，就是向这个索引结点写入数据的
- `user_dst`：1要写入索引结点的数据来自于用户空间，0要写入索引结点的数据来自于内核空间
- `src`：源地址，存放的是要保存到索引结点的数据
- `off`：要写入的数据在索引结点里的位置
- `n`：要写入的数据有多少个字节
- 返回值(int)：实际写入了多少个字节
- 执行过程：逐块地把数据写入到索引结点里

#### 五、目录层

目录层的作用是把索引结点组织起来，形成一个树状结构，树根就是根目录。这样只要知道根目录在哪里，就能定位到所有的文件了。在这一层里索引结点有名字了，即通常所说的文件名。

根目录在用户数据区的第一个块上，这在文件系统创建的时候就决定了。

目录层向上提供了如下接口：

`dirlookup`

`dirlink`

#### 六、路径名层

#### 七、文件描述符层