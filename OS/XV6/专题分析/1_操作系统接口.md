操作系统的任务是在多个进程之间共享计算机，并提供比硬件本身支持更有用的服务。操作系统抽象和管理底层的硬件，以使上层的程序不必关心硬件的细节。它也在多个进程之间共享硬件，这样多个进程就可以同时运行了。最终，操作系统为程序提供了受控的交互方式，让它们可以共享数据或同时工作。

操作系统使用接口来为用户程序提供服务。设计一个好的接口是困难的。一方面我们希望它简单以便于正确地实现，另一方面我们又希望能提供大量复杂的特性。解决这一矛盾的技巧是，在设计接口的时候让它们依赖一些机制，这些机制可以组合起来提供更多的通用性。

xv6实现了Unix的基本接口，并模仿了它的内部设计。

xv6有内核，用以为运行的程序提供服务。运行的程序，即进程，有自己的内存用以包含指令、数据和栈。

进程通过系统调用使用系统服务。这样，进程就在内核空间和用户空间之间切换。

在内核层面实现了进程隔离的机制。

本章的其余部分概述了xv6提供的服务：进程、内存、文件描述符、管道、文件系统，并讨论了shell。

shell只是一个普通的程序，它从用户那里读取命令并执行它们。它的代码在user/sh.c。

#### 从内核态到用户态

在xv6启动的过程中，0号核在main函数里会执行userinit函数，标记initcode处的数据会复制到第一个用户进程的内存空间。标记initcode的数字是一段代码，它对应的内容在user/initcode.S，是要把文件init的内容放到内存里以用户态去执行。文件init编译自user/init.c。

user/init.c把文件sh放到内存里执行。文件sh编译自user/sh.c，把用户输入的命令调入内存中执行，它就是xv6的shell。shell就是不断地使用getcmd函数读取命令行的输入，然后使用runcmd函数来执行命令行的输入。

#### 从用户态到内核态

系统调用怎么从用户态到的内核态呢？文件user/usys.pl生成user/usys.S，usys.S就是用来完成从用户态到内核态的代码。从代码可见，它是通过ecall产生一个异常来进入内核态。只要把usys.S生成的二进制文件链接进用户程序里，就可以使用系统调用了。

#### 进程和内存

xv6的进程包含两部分：一是用户空间的内存，一是仅内核可见的进程状态。

相关系统调用的实现请看kernel/sysproc.c。

##### fork

文件位置：kernel/proc.c。作用：创建一个进程，新进程的内存和父进程是完全一样的。

fork函数一次调用两次返回，这很怪异，因为一般的调用都是只返回一次的。fork从父进程返回很正常，但为什么会从子进程返回呢？这是因为子进程继承了父进程的所有资源，这一句`*(np->tf) = *(p->tf)`相当于子进程复制了父进程运行的“快照”，子进程里也相当于进行了一个fork函数且从下一句开始执行。

1. p为当前进程，np为子进程。
2. uvmcopy把父进程的内存复制给子进程。
3. `np->tf->a0 = 0`保证了子进程返回0，因为寄存器a0保存了函数的返回值。
4. `return pid`对于子进程来说，在汇编层面应该实际执行的返回寄存器a0的值。

##### exit

文件位置：kernel/proc.c。作用：让调用它的进程停止运行并释放资源(如内存、打开的文件等)。`exit`有一个整型的状态参数，通常0代表成功，1代表失败。

##### wait

文件位置：kernel/proc.c。作用：等待当前进程的某个子进程退出；如果有子进程退出，返回该进程的pid，并把退出状态复制到传递给它的地址上。如果不关心子进程的退出状态，可以直接给wait传递参数0。

##### exec

文件位置：kernel/exec.c。作用：把当前进程的内存替换为文件里保存的内存镜像并执行之。`exec`有两个参数，第一个是要执行的程序，第二个这个程序的参数(以字符串数组的形式出现)。

`exec`首先用`namei`来打开文件`path`。然后，读取ELF header。xv6的程序是用ELF格式来读取的(ELF格式详见kernel/elf.h)。在一个ELF二进制里，ELF header(`struct elfhdr`)在头部的位置，接下来是些程序头(`struct proghdr`)，每个程序头都描述了一个必须被载入内存里的段(section)。xv6的程序只有一个程序头，但其它系统指令和数据可能会有不同的段(section)。

第一步是快速检查文件是否正确包含了一个ELF二进制。ELF二进制的开头部分是一个魔数，0x7f后面跟字符串"ELF"。如果魔数能对的上，`exec`就认为这个二进制是正确的。

`exec`使用`proc_pagetable`分配了一个没有映射的新页表，然后用`uvmalloc`来为每个ELF段分配内存，并用`loadseg`把每个ELF段载入内存。`loadseg`使用`walkaddr`来找到将要写入ELF段的物理地址，然后用`readi`来把文件中的内容载入到该地址。

可以用`objdump -p`来查看程序头的内容。在程序头里`filesz`可能比`memsz`小，这表示它们之间的间隙(gap)应该用0来填充，而不是从文件里读取。

接下来该分配和初始化用户的栈了。它只为栈分配了一个页。`exec`依次把参数复制到栈顶，然后把到这些参数的指针记录在`ustack`里。在传给`main`函数的`argv`列表里，最末尾放了一个空指针。`ustack`的前三个入口分别是假的返回PC，`argc`，`argv`的指针。

`exec`在栈的下面放了一个不可访问的页，这样栈溢出的时候就会报错。这个不可访问的页也使得exec可以处理太长的参数；当参数太长的时候，`exec`用来把参数复制到栈的函数`copyout`将会提示目标页不可访问，并返回1。

在准备新的内存镜像的时候，如果`exec`检测到一个错误(比如无效的程序段)，将会跳转到标记`bad`，释放新的镜像，并返回1。`exec`必须等到系统调用执行成功才可以释放掉旧的镜像；如果旧的镜像没有了，系统调用就没有办法向它返回1了。`exec`的错误只可能发生在镜像创立期间。一旦镜像完成，`exec`就可以提交到新的页表并释放旧的页表。

`exec`按ELF文件定义的地址把ELF文件载入到内存。用户或进程可以在ELF文件里指定任意地址。这是危险的，因为这些地址可能指向内核，不管是有意还无意。一个不严谨的内核将导致若干不好的结果，从崩溃到对隔离机制的恶意破坏(如安全漏洞)。xv6进行了一系列检查来避免这些风险。如`if(ph.vaddr + ph.memsz < ph.vaddr)`检查两者相加是否溢出。在x86版的xv6中，如果`ph.memsz`足够大而溢出0x1000，用户是有可能把数据复制到内核里的。在RISC-V版的xv6中则无此问题，因为内核和用户分别有各自的页表。

内核开发者很容易忽略一个重要的检查，在真实的世界中由于没有进行检查而使用户程序获取内核权限的事情已经有很长的历史了。xv6对提供给内核的用户数据的检查很可能是不全面的，用户程序是有可能绕过xv6的隔离机制的。

##### sbrk

文件位置：kernel/sysproc.c。作用：为进程分配或回收内存。它有一个参数，代表要分配的字节数。它返回的是新分配内存的地址。

这个系统调用是通过`growproc`来实现的。`growproc`使用`uvmalloc`来分配内存，如果给的参数是正数。或使用`uvmdealloc`来释放内存，如果给的参数是负数。

`uvmalloc`首先使用`kalloc`来分配物理内存，然后再用`mappages`把PTE加到用户的页表里。`uvmdealloc`调用`uvmunmap`实现其功能，`uvmunmap`首先用`walk`来找到对应的PTE，然后使用`kfree`来释放相应的物理内存。

xv6里进程的页表不只是告诉硬件怎么映射到虚拟地址，也是分配给那个进程的物理内存页的唯一记录。这就是为什么`uvmunmap`在释放用户内存的时候需要对用户页表进行检查。

##### shell

文件位置：user/sh.c。shell结构简单，在`main`函数里可以看到它的主循环就是不断地使用`getcmd`来读取用户输入。然后使用`fork`来创建一个子进程。父进程调用`wait`来等待子进程执行命令。子进程调用`runcmd`来执行真正的命令。

既然`fork`之后肯定要执行`exec`，为什么不把它们合而为一呢？这是为了在I/O重定向的时候方便使用。`fork`复制的内存基本上是无用的，会在随后被`exec`替换掉，为了防止复制过程的资源浪费，可以使用虚拟内存的技术(如写时复制copy-on-write)。

在xv6里没有多用户的概念。用Unix术语来说，所有xv6进程都是作为根用户来运行的。

#### I/O和文件描述符

一个文件描述符是一个小的整数，它代表了一个内核管理的对象(kernel-managed object)，进程对这个对象进行读写操作。进程可能通过如下方法获取文件描述符，打开文件、目录或设备，创建管道，复制一个已有的描述符。为简单起见，文件描述符指向的对象都被称为是“文件”；文件描述符抽象出来文件、管道和设备的共同点，使它们看起来都像是字节流。

在每个进程表里都把文件描述符作为索引，这样每个进程都有文件描述符的私有空间，文件描述符都是从0开始计数。按照惯例，0是标准输入，1是标准输出，2是标准错误。shell就是使用的这个约定实现的I/O重定向和管道。shell始终打开了三个文件描述符，作为控制台的默认文件描述符。

相关系统调用的实现请看kernel/sysfile.c。

##### read

文件位置kernel/file.c。作用：从文件描述符所指向的文件读取n个字节。

##### write

文件位置kernel/file.c。作用：从文件描述符所指向的文件写入n个字节。

##### close

##### open

##### pipe

##### dup

##### chdir

##### mkdir

##### mknod

##### fstat

##### link

##### unlink

#### 管道

#### 文件系统



