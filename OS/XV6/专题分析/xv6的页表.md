操作系统通过页表来向每个进程提供私有的地址空间和内存。页表决定了内存地址的含义，哪些物理内存可以访问。xv6使用页表分隔不同进程的地址空间，并把它们多路复用到单一的物理内存。xv6还使用页表实现了一些技巧：把同一块内存映射到多个地址空间(a trampoline page)，使用未映射的页来保护内核和用户的栈。

#### 分页硬件

RISC-V页表硬件通过把虚拟地址映射到物理地址的方式来把它们连接在一起。

xv6运行Sv39的分页方式，这种分页方式只使用64位虚拟地址里的低39位，高25位并未使用。在这39位有效位里，低12位是offset，剩下27位是index，这意味着每个页表在逻辑上对应着2<sup>27</sup>个PTE(页表入口)。每个PTE占用64位，低54位有效，高10位是保留位。在这54位有效位里，低10位是flags，高44位是PPN(物理页号)。虚拟地址所对应的物理地址是56位的，它的高44位来自于PTE的PPN，它的低12位来自于虚拟地址的offset。

Sv39的页表在物理内存里实际存在的形式是三级树(three-level tree)。树根是个4K的页，包含了512个PTE，每个PTE都对应了第二级的1个页，每个页都包含了第三级的512个PTE。虚拟地址的27位index里，高9位用来选择树根的PTE，中间9位用来选择二级页表页的PTE，低9位用来选择最终的PTE。

通常情况下，大部分的虚拟地址都是没有映射的。

PTE有10位的flag，可以在kernel/riscv.h看到xv6对于它们的定义。`PTE_V`的意思是此条PTE是否存在(1:存在，0:不存在)；`PTE_R`、`PTE_W`、`PTE_X`分别代表所对应的页是否可读、写、执行。`PTE_U`代表用户模式下是否可以访问此页。

内核需要把根页表页的物理地址放到satp寄存器里，硬件才能使用页表。每个CPU都有一个satp寄存器。这意味着每个CPU都可以有自己私有的地址空间，进而运行各自的进程。

#### 内核地址空间

#### 创建地址空间

#### 物理内存分配

#### 物理内存分配器

#### 进程地址空间

#### sbrk

#### exec