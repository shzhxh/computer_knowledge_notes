翻译自：Stride Scheduling:Deterministic Proportional-Share Resource Management （Carl A. Waldspurger & William E. Weihl）  
#### 摘要  
**stride调度** 是一种确定性的调度技术，它有效的支持了与 **lottery调度** 相同的资源管理抽象。与 **lottery调度** 相比，**stride调度** 显著提高了相关吞吐量速率的准确度，响应时间变异度显著降低。**stride调度** 实现了对处理器时间和其它资源的 **比例共享** 控制，这是通过交叉应用基于速率的网络流量控制算法的元素来实现的。我们引入了新技术以支持动态改变和更高级别的资源管理抽象。我们还引入了一种新的 **分层stride调度** 算法，进一步提高了吞吐量速率的准确度且降低了响应时间变异度。使用为Linux内核实现的模拟和原型两者共同评估stride模型。  

#### 1. 介绍  
  多线程系统的调度器必须复用稀缺资源以服务不同重要度的请求。为了获得用户和应用程序的服务速率目标，需要精确控制相对计算速率。这种控制在广泛的系统中是可取的，包括数据库、基于媒体的应用程序和网络。例子包括对竞争视频查看器的帧速率的控制、数据库和Web服务器对并发客户机的查询，以及长期运行的计算对共享源的消耗。  
  很少有通用的方法被提出，以支持灵活的、响应性的服务速率控制。我们最近推出的 **lottery调度**，一个随机的资源分配机制，它提供了高效的、对相关计算率的响应控制。**lottery调度** 实现 **比例共享** 资源管理——主动客户机的资源消耗率与分配给它们的相对份额成比例。更高层抽象的灵活性，与 **lottery调度** 相同的模块化的资源管理，但他们不依赖于按比例分享的随机实现。  
  **stride调度** 是一个确定性的调度技术，它与 **lottery调度** 一样有效地支持灵活的资源管理抽象。我们工作的一个贡献是基于速率的流量控制算法的交叉应用和推广，它是为网络而设计的，现在用于处理其他资源例如处理器时间。我们提出了支持动态操作的新技术，例如修改相关分配和客户间资源权利的转移。我们还引入了一种新的 **分层stride调度** 算法。**分层stride调度** 是对基本技术的递归应用，它比以前的方案具有更好的吞吐率和较低的响应时间可变性。  
  仿真结果表明，与 **lottery调度** 相比，**stride调度** 显著提高了相对吞吐量率的准确度，响应时间变异性显著降低。与其他确定性方案相比，**stride调度** 有效地支持动态修改相关分配和竞争资源的客户数量的操作。我们还为Linux内核实现了原型stride调度器，发现它们能够精确地控制处理器时间和竞争套接字的相关网络传输速率。  
  在下一节中，我们提出了核心 **stride调度** 机制。第3节描述了与 **lottery调度** 相同的资源管理抽象的扩展。第4节介绍 **分层stride调度** 。与 **lottery调度** 定量比较的模拟结果出现在第5节中。我们在第6节讨论了我们的Linux原型和相关的实现问题。在第7节中，我们将研究相关的工作。最后，我们概述我们的结论在8节。

#### 2. stride调度算法
  stride调度是对共享时间资源的确定性分配机制。资源是在离散的 **时间片** 中分配的。我们指的是作为 **量子** 的标准时间片持续时间。资源的权重是由 **选票** 来表示的，它是抽象的、一流的对象，可以以不同数量发布，在不同客户端之间传递。活跃客户端的吞吐量速率直接正比于它们的选票分配。因此，一个拥有两倍选票的客户端将在给定时间内获得两倍的资源。客户端响应时间与选票分配成反比。因此，一个拥有两倍选票的客户端只需等待一半的时间即可获取资源。  
  本节首先介绍了基本的stride调度算法，然后介绍了各种扩展，诸如支持动态客户端参与、选票分配的动态修改和非均匀量子。
  1. 基本算法  
     stride调度的核心思想是计算时间间隔，或者叫 **步长** （注：步长的英文单词即stride），的表示法。它是客户端在连续分配之间必须等待的时间间隔。拥有最小步长的客户端将会被最频繁地调度。一个拥有一半步长的客户端将拥有2倍的执行速度，一个拥有两倍步长的客户端执行速度也将慢两倍。步长是由叫做 **传递** 的虚拟时间单位来表示的，而不是真实的时间单位诸如秒之类的。  
     每个客户端有三个状态变量： **选票**, **步长** 和 **传递**。**选票** 域指定了客户端相较于其它客户端的资源分配。**步长** 域与 **选票** 成反比，表示由 **传递** 来测量的选举之间的间隔。**传递** 表示客户端下一次选举的虚拟时间索引。  
     执行资源分配非常简单：选择最小 **传递** 的客户端，通过它的 **步长** 推进它的 **传递**。如果有多个客户端拥有最小传递值，它们中任何一个都可被选举。一个合理的确定性方法是使用一致的顺序来断开连接，例如由唯一的客户标识符定义的关系。  
     基本stride调度算法的ANSY C代码如下。为简单起见，我们假定了一个客户端的静态集合，它们有固定的选票分配。每个客户端的步长调度状态在使用allocate()初始化之前必须通过客户端init()初始化。这些限制将在随后章节放宽，以充许更动态的行为。  
     ```
     /* per-client state */
     typedef struct {
       ...
       int tickets, stride, pass;
     } *client_t ;

     /* large integer stride constant (e.g. 1M) */
     const int stride1 = (1 << 20);

     /* current resource owner */
     client_t current ;

     /* initialize client with specified allocation * /
     void client_init (client_t c, queue_t q, int tickets)
     {
       /* stride is inverse of tickets */
       c->tickets = tickets;
       c->stride = stride1 / tickets;
       c->pass = c->stride;
       /* join competition for resource */
       queue_insert(q, c);
     }

     /* proportional-share resource allocation */
     void allocate (queue_t q)
     {
        /* select client with minimum pass value */
        current = queue_remove_min(q);
        /* use resource for quantum */
        use_resource(current);
        /* compute next pass using stride */
        current->pass += current->stride;
        queue_insert(q, current);
     }
     ```
    为了准确表示作为 **选票** 倒数的 **步长**，可以用浮点表示法。我们提出了一个更有效的替代方案，使用高精度定点整数表示。通过将选票值的倒数乘一个大整数常量的方法很容易实现。我们将引用这个常量作为 **stride1**，因为它表示对应于最小选票分配的步长。  
    分配的开销取决于实现客户端队列的数据结构。
  2. 动态客户端参与
  3. 动态选票修改
  4. 非均匀量子

#### 3. 灵活的资源管理
  1. 选票转换
  2. 选票通涨
  3. 选票流通

#### 4. 分层的stride调度算法
  1. 基本算法
  2. 动态修改

#### 5. 模拟结果
  1. 吞吐量精度
  2. 动态选票分配
  3. 响应时间可变性
  4. 分层的stride调度算法

#### 6. 原型实现
  1. 进程调度器
  2. 网络设备调度器

#### 7. 相关工作
  1. 基于速率的网络流量控制
  2. 比例共享调度器
  3. 优先权调度器
  4. 实时调度器
  5. 微观经济调度器

#### 8. 结论
